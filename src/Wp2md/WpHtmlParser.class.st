"
This is a parser for HTML generated by WordPress when it exports its page contents.
"
Class {
	#name : #WpHtmlParser,
	#superclass : #PP2CompositeNode,
	#instVars : [
		'commentStart',
		'commentEnd',
		'commentTag',
		'attributeName',
		'attribute',
		'tagName',
		'tagStart',
		'tagEnd',
		'tagEmpty',
		'plainText',
		'break',
		'balancedHTML',
		'html',
		'tagNotEmpty'
	],
	#category : #'Wp2md-Parser'
}

{ #category : #grammar }
WpHtmlParser >> attribute [
	"Sometimes we see the special case `download` without any value assigned."

	^ ((attributeName , $= asPParser , $" asPParser
		, $" asPParser negate star flatten , $" asPParser)
		==> [ :node | node first -> node fourth ])
		/ ('download' asPParser ==> [ :node | node first -> '' ])
]

{ #category : #grammar }
WpHtmlParser >> attributeName [
	^ (#letter asPParser / #digit asPParser / $- asPParser) plus flatten
]

{ #category : #grammar }
WpHtmlParser >> balancedHTML [
	^ plainText / commentTag / break / tagEmpty
		/ tagNotEmpty
]

{ #category : #grammar }
WpHtmlParser >> break [
	^ '<br>' asPParser
		==> [ :node | 
			(self nodeForTag: 'br')
				tag: 'br';
				yourself ]
]

{ #category : #grammar }
WpHtmlParser >> commentEnd [
	^ '-->' asPParser
]

{ #category : #grammar }
WpHtmlParser >> commentStart [
	^ '<!--' asPParser
]

{ #category : #grammar }
WpHtmlParser >> commentTag [
	^ (commentStart , commentEnd negate star flatten , commentEnd) trim
		==> [ :node | 
			WpCommentNode new
				comment: node second;
				yourself ]
]

{ #category : #grammar }
WpHtmlParser >> html [
	^ balancedHTML star end ==> [ :node | WpDocumentNode new children: node ]
]

{ #category : #utility }
WpHtmlParser >> nodeForTag: aTag [
	^ (self nodeTypeDictionary at: aTag ifAbsent: [ WpGenericNode ]) new
]

{ #category : #utility }
WpHtmlParser >> nodeTypeDictionary [
"TODO:
blockquote
ol
pre"
	^ {'a' -> WpANode.
		'br' -> WpBreakNode.
		'comment' -> WpCommentNode.
		'div' -> WpContainerNode.
		'document' -> WpDocumentNode.
		'em' -> WpEmphNode.
		'figure' -> WpContainerNode.
		'figcaption' -> WpContainerNode.
		'h1' -> WpHeaderNode.
		'h2' -> WpHeaderNode.
		'h3' -> WpHeaderNode.
		'li' -> WpLiNode.
		'p' -> WpPNode.
		'span' -> WpContainerNode.
		'strong' -> WpStrongNode.
		'table' -> WpTableNode.
		'tbody' -> WpContainerNode.
		'td' -> WpContainerNode.
		'text' -> WpTextNode.
		'tr' -> WpContainerNode.
		'ul' -> WpUlNode} asDictionary
]

{ #category : #grammar }
WpHtmlParser >> plainText [
	^ ($< asPParser / $> asPParser) negate plus flatten
		==> [ :node | 
			WpTextNode new
				text: node;
				yourself ]
]

{ #category : #accessing }
WpHtmlParser >> start [
	^ html
]

{ #category : #grammar }
WpHtmlParser >> tagEmpty [
	^ ($< asPParser , tagName , attribute trim star , '/>' asPParser)
		==> [ :node | 
			(self nodeForTag: node second)
				tag: node second;
				attributeDict: node third asDictionary;
				yourself ]
]

{ #category : #grammar }
WpHtmlParser >> tagEnd [
	^ '</' asPParser , tagName , $> asPParser
]

{ #category : #grammar }
WpHtmlParser >> tagName [
	^ (#letter asPParser / #digit asPParser) plus flatten
]

{ #category : #grammar }
WpHtmlParser >> tagNotEmpty [
	^ (tagStart , balancedHTML star , tagEnd)
		==> [ :node | 
			node first
				children: node second;
				yourself ]
]

{ #category : #grammar }
WpHtmlParser >> tagStart [
	^ ($< asPParser , tagName , attribute trim star , $> asPParser)
		==> [ :node | 
			(self nodeForTag: node second)
				tag: node second;
				attributeDict: node third asDictionary;
				yourself ]
]
